/*
 * generated by Xtext
 */
package com.blasedef.onpa.validation


import org.eclipse.xtext.validation.Check
import com.blasedef.onpa.oNPA.Expression
import com.blasedef.onpa.oNPA.Sub
import com.blasedef.onpa.oNPA.Plu
import com.blasedef.onpa.oNPA.Mul
import com.blasedef.onpa.oNPA.Div
import java.util.ArrayList
import java.util.Set
import java.util.HashSet
import com.blasedef.onpa.oNPA.ONPAPackage
import com.blasedef.onpa.oNPA.Or
import com.blasedef.onpa.oNPA.And
import com.blasedef.onpa.oNPA.Equality
import com.blasedef.onpa.oNPA.Comparison
import com.blasedef.onpa.oNPA.Not
import com.blasedef.onpa.oNPA.ReferencedStore
import com.blasedef.onpa.oNPA.Store
import com.blasedef.onpa.oNPA.FreeVariable
import com.blasedef.onpa.oNPA.Model
import com.blasedef.onpa.oNPA.ProcessExpression
import com.blasedef.onpa.oNPA.Process
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ONPAValidator extends AbstractONPAValidator {
	
	//STORE
	
	public static val SELF_REFERENCING_STORE = 'selfReferencingStore'
	
	@Check
	def checkNotSelfReferencing(Store store){
			
		var ArrayList<String> strings = new ArrayList<String>();
		
		strings.add(store.name)
		
		findReferencedRates(store.value,strings)
		
		var Set<String> setOfString = new HashSet<String>(strings);
		
		if(setOfString.size == strings.size)
			return //because there can't be any duplicates
		else
			error("Cannot have self referencing stores. '" + store.name + "' is seen in the expression",
				ONPAPackage::eINSTANCE.store_Value,
				com.blasedef.onpa.validation.ONPAValidator.SELF_REFERENCING_STORE
			)
		
	}
	
	def void findReferencedRates(Expression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}
	
	public static val STORE_NAMES_UNIQUE = 'storeNamesUnique'
	
	@Check
	def checkStoresNamesUnique(Store store){
		
		var stores = getContainerOfType(store, typeof(Model)).stores
		
		var count = 0
		
		for(st : stores)
			if(st.name.contains(store.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique store names. '" + store.name + "' is repeated",
				ONPAPackage::eINSTANCE.store_Name,
				STORE_NAMES_UNIQUE
			)
			
	}
	
	//PROCESS
	
	public static val PROCESS_NAMES_UNIQUE = 'processNamesUnique'
	
	@Check
	def checkensureProcessCycles(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.contains(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				ONPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}


//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
