/*
 * generated by Xtext
 */
package com.blasedef.onpa.validation


import org.eclipse.xtext.validation.Check
import com.blasedef.onpa.oNPA.Expression
import com.blasedef.onpa.oNPA.Sub
import com.blasedef.onpa.oNPA.Plu
import com.blasedef.onpa.oNPA.Mul
import com.blasedef.onpa.oNPA.Div
import java.util.ArrayList
import java.util.Set
import java.util.HashSet
import com.blasedef.onpa.oNPA.ONPAPackage
import com.blasedef.onpa.oNPA.Or
import com.blasedef.onpa.oNPA.And
import com.blasedef.onpa.oNPA.Equality
import com.blasedef.onpa.oNPA.Comparison
import com.blasedef.onpa.oNPA.Not
import com.blasedef.onpa.oNPA.ReferencedStore
import com.blasedef.onpa.oNPA.DoubleConstant
import com.blasedef.onpa.oNPA.BoolConstant
import com.blasedef.onpa.oNPA.Store
import com.blasedef.onpa.oNPA.FreeVariable
import com.blasedef.onpa.oNPA.Model
import com.blasedef.onpa.oNPA.ProcessExpression
import com.blasedef.onpa.oNPA.Process
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ONPAValidator extends AbstractONPAValidator {
	
	
	public static val SELF_REFERENCING_RATE = 'selfReferencingRate'
	
	@Check
	def checkNotSelfReferencing(Store store){
			
		var ArrayList<String> strings = new ArrayList<String>();
		
		strings.add(store.name)
		
		findReferencedRates(store.value,strings)
		
		var Set<String> setOfString = new HashSet<String>(strings);
		
		if(setOfString.size == strings.size)
			return //because there can't be any duplicates
		else
			error("Cannot have self referencing stores. '" + store.name + "' is seen in the expression",
				ONPAPackage::eINSTANCE.store_Value,
				SELF_REFERENCING_RATE
			)
		
	}
	
	def void findReferencedRates(Expression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}
	
	public static val UNIQUE_VARIABLE_NAMES_STORES = 'uniqueVariableNamesStores'
	
	@Check
	def checkUniqueVariableNamesStores(Store store){
		
		var stores = getContainerOfType(store, typeof(Model)).stores
		
		var count = 0
		
		for(st : stores)
			if(st.name.contains(store.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique store names. '" + store.name + "' is repeated",
				ONPAPackage::eINSTANCE.store_Name,
				UNIQUE_VARIABLE_NAMES_STORES
			)
			
	}
	
	public static val ENSURE_PROCESS_CYCLES = 'ensureProcessCycles'
	
	@Check
	def checkensureProcessCycles(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
			
	}
	
	def void findReferencedProcesses(ProcessExpression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
