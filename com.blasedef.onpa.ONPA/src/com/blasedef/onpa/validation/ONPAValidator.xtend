/*
 * generated by Xtext
 */
package com.blasedef.onpa.validation


import org.eclipse.xtext.validation.Check
import com.blasedef.onpa.oNPA.Expression
import com.blasedef.onpa.oNPA.Sub
import com.blasedef.onpa.oNPA.Plu
import com.blasedef.onpa.oNPA.Mul
import com.blasedef.onpa.oNPA.Div
import java.util.ArrayList
import com.blasedef.onpa.oNPA.ONPAPackage
import com.blasedef.onpa.oNPA.Or
import com.blasedef.onpa.oNPA.And
import com.blasedef.onpa.oNPA.Equality
import com.blasedef.onpa.oNPA.Comparison
import com.blasedef.onpa.oNPA.Not
import com.blasedef.onpa.oNPA.ReferencedStore
import com.blasedef.onpa.oNPA.Store
import com.blasedef.onpa.oNPA.FreeVariable
import com.blasedef.onpa.oNPA.Model
import com.blasedef.onpa.oNPA.ProcessExpression
import com.blasedef.onpa.oNPA.Process
import static extension org.eclipse.xtext.EcoreUtil2.*
import com.google.inject.Inject
import org.eclipse.emf.ecore.EReference
import com.blasedef.onpa.typing.ExpressionsType
import com.blasedef.onpa.oNPA.ActionNot
import com.blasedef.onpa.oNPA.ActionExpression
import com.blasedef.onpa.oNPA.ActionOr
import com.blasedef.onpa.oNPA.ActionAnd
import com.blasedef.onpa.oNPA.ActionEquality
import com.blasedef.onpa.oNPA.ActionComparison
import com.blasedef.onpa.oNPA.ActionSub
import com.blasedef.onpa.oNPA.ActionPlu

import static extension com.blasedef.onpa.typing.ModelUtil.*
import com.blasedef.onpa.oNPA.ActionMul
import com.blasedef.onpa.oNPA.ActionDiv
import com.blasedef.onpa.oNPA.UpdateExpression
import com.blasedef.onpa.typing.ETypeProvider
import com.blasedef.onpa.typing.ATypeProvider
import com.blasedef.onpa.typing.ActionType
import com.blasedef.onpa.oNPA.LocalUpdateExpression

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ONPAValidator extends AbstractONPAValidator {
	
	//STORE
	
	public static val SELF_REFERENCING_STORE = 'com.blasedef.onpa.dice.selfReferencingStore'
	
//	@Check
//	def void checkForwardReference(VariableRef varRef) {
//		val variable = varRef.getVariable()
//		if (variable != null && !varRef.variablesDefinedBefore.contains(
//				variable)) {
//			error("variable forward reference not allowed: '"
//					+ variable.name + "'",
//					ExpressionsPackage::eINSTANCE.variableRef_Variable,
//					FORWARD_REFERENCE, variable.name)
//		}
//	}
	
	@Check
	def checkNotSelfReferencing(ReferencedStore refStore){
			
		val store = refStore.value
		if(store != null && refStore.selfReferencedStores == store)
			error("Cannot have self referencing stores. '" + refStore.value.name + "' is seen in the expression",
				ONPAPackage::eINSTANCE.referencedStore_Value,
				com.blasedef.onpa.validation.ONPAValidator.SELF_REFERENCING_STORE
			)
		
	}
	
	def void findReferencedRates(Expression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}
	
	public static val STORE_NAMES_UNIQUE = 'com.blasedef.onpa.dice.storeNamesUnique'
	
	@Check
	def checkStoresNamesUnique(Store store){
		
		var stores = getContainerOfType(store, typeof(Model)).stores
		
		var count = 0
		
		for(st : stores)
			if(st.name.contains(store.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique store names. '" + store.name + "' is repeated",
				ONPAPackage::eINSTANCE.store_Name,
				STORE_NAMES_UNIQUE
			)
			
	}
	
	//PROCESS
	
	public static val PROCESS_NAMES_UNIQUE = 'com.blasedef.onpa.dice.processNamesUnique'
	
	@Check
	def checkensureProcessCycles(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.contains(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				ONPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Inject extension ETypeProvider
	
	public static val WRONG_TYPE = "com.blasedef.onpa.dice.WrongType";
	
	@Check
	def checkType(Not not) {
		checkExpectedBoolean(not.expression,
				ONPAPackage$Literals::NOT__EXPRESSION)
	}
	
	@Check
	def checkType(ActionNot not) {
		checkExpectedBoolean(not.expression,
				ONPAPackage$Literals::ACTION_NOT__EXPRESSION)
	}
	
	@Check
	def checkType(Or or){
		checkExpectedBoolean(or.left,
			ONPAPackage$Literals::OR__LEFT
		)
		checkExpectedBoolean(or.right,
			ONPAPackage$Literals::OR__RIGHT
		)
	}
	
	@Check
	def checkType(ActionOr or){
		checkExpectedBoolean(or.left,
			ONPAPackage$Literals::ACTION_OR__LEFT
		)
		checkExpectedBoolean(or.right,
			ONPAPackage$Literals::ACTION_OR__RIGHT
		)
	}
	
	@Check
	def checkType(And and){
		checkExpectedBoolean(and.left,
			ONPAPackage$Literals::AND__LEFT
		)
		checkExpectedBoolean(and.right,
			ONPAPackage$Literals::AND__RIGHT
		)
	}
	
	@Check
	def checkType(ActionAnd and){
		checkExpectedBoolean(and.left,
			ONPAPackage$Literals::ACTION_AND__LEFT
		)
		checkExpectedBoolean(and.right,
			ONPAPackage$Literals::ACTION_AND__RIGHT
		)
	}
	
	@Check
	def checkType(Equality eq){
		checkExpectedBoolean(eq.left,
			ONPAPackage$Literals::EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			ONPAPackage$Literals::EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(ActionEquality eq){
		checkExpectedBoolean(eq.left,
			ONPAPackage$Literals::ACTION_EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			ONPAPackage$Literals::ACTION_EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(Comparison com){
		checkExpectedDouble(com.left,
			ONPAPackage$Literals::COMPARISON__LEFT
		)
		checkExpectedDouble(com.right,
			ONPAPackage$Literals::COMPARISON__RIGHT
		)
	}
	
	@Check
	def checkType(ActionComparison com){
		checkExpectedDouble(com.left,
			ONPAPackage$Literals::ACTION_COMPARISON__LEFT
		)
		checkExpectedDouble(com.right,
			ONPAPackage$Literals::ACTION_COMPARISON__RIGHT
		)
	}
	
	@Check
	def checkType(Sub sub){
		checkExpectedDouble(sub.left,
			ONPAPackage$Literals::SUB__LEFT
		)
		checkExpectedDouble(sub.right,
			ONPAPackage$Literals::SUB__RIGHT
		)
	}
	
	@Check
	def checkType(ActionSub sub){
		checkExpectedDouble(sub.left,
			ONPAPackage$Literals::ACTION_SUB__LEFT
		)
		checkExpectedDouble(sub.right,
			ONPAPackage$Literals::ACTION_SUB__RIGHT
		)
	}
	
	@Check
	def checkType(Plu plu){
		checkExpectedDouble(plu.left,
			ONPAPackage$Literals::PLU__LEFT
		)
		checkExpectedDouble(plu.right,
			ONPAPackage$Literals::PLU__RIGHT
		)
	}
	
	@Check
	def checkType(ActionPlu plu){
		checkExpectedDouble(plu.left,
			ONPAPackage$Literals::ACTION_PLU__LEFT
		)
		checkExpectedDouble(plu.right,
			ONPAPackage$Literals::ACTION_PLU__RIGHT
		)
	}
	
	@Check
	def checkType(Mul mul){
		checkExpectedDouble(mul.left,
			ONPAPackage$Literals::MUL__LEFT
		)
		checkExpectedDouble(mul.right,
			ONPAPackage$Literals::MUL__RIGHT
		)
	}
	
	@Check
	def checkType(ActionMul mul){
		checkExpectedDouble(mul.left,
			ONPAPackage$Literals::ACTION_MUL__LEFT
		)
		checkExpectedDouble(mul.right,
			ONPAPackage$Literals::ACTION_MUL__RIGHT
		)
	}
	
	@Check
	def checkType(Div div){
		checkExpectedDouble(div.left,
			ONPAPackage$Literals::DIV__LEFT
		)
		checkExpectedDouble(div.right,
			ONPAPackage$Literals::DIV__RIGHT
		)
	}
	
	@Check
	def checkType(ActionDiv div){
		checkExpectedDouble(div.left,
			ONPAPackage$Literals::ACTION_DIV__LEFT
		)
		checkExpectedDouble(div.right,
			ONPAPackage$Literals::ACTION_DIV__RIGHT
		)
	}
	

	@Check
	def checkType(LocalUpdateExpression updateExpression){
		checkExpectedSelfReference(updateExpression.name,
			ONPAPackage$Literals::UPDATE_EXPRESSION__NAME
		)
		checkExpectedDouble(updateExpression.expression,
			ONPAPackage$Literals::UPDATE_EXPRESSION__EXPRESSION
		)
	}
	
	def private checkExpectedSelfReference(Expression exp, EReference reference){
		checkExpectedType(exp, ATypeProvider::selfReferencedStoreType, reference)
	}
	
	def private checkExpectedBoolean(Expression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedBoolean(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedDouble(Expression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedDouble(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, ETypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedType(ActionExpression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (!(actualType == expectedType || actualType == ETypeProvider::freeVariableType))
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private checkExpectedType(Expression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private checkExpectedType(Expression exp,
			ActionType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(ActionExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(Expression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
