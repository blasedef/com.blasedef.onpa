/*
 * generated by Xtext
 */
package com.blasedef.onpa.validation


import org.eclipse.xtext.validation.Check
import com.blasedef.onpa.oNPA.Expression
import com.blasedef.onpa.oNPA.Sub
import com.blasedef.onpa.oNPA.Plu
import com.blasedef.onpa.oNPA.Mul
import com.blasedef.onpa.oNPA.Div
import java.util.ArrayList
import java.util.Set
import java.util.HashSet
import com.blasedef.onpa.oNPA.ONPAPackage
import com.blasedef.onpa.oNPA.Or
import com.blasedef.onpa.oNPA.And
import com.blasedef.onpa.oNPA.Equality
import com.blasedef.onpa.oNPA.Comparison
import com.blasedef.onpa.oNPA.Not
import com.blasedef.onpa.oNPA.ReferencedStore
import com.blasedef.onpa.oNPA.Store
import com.blasedef.onpa.oNPA.FreeVariable
import com.blasedef.onpa.oNPA.Model
import com.blasedef.onpa.oNPA.ProcessExpression
import com.blasedef.onpa.oNPA.Process
import static extension org.eclipse.xtext.EcoreUtil2.*
import com.google.inject.Inject
import com.blasedef.onpa.typing.TypeProvider
import org.eclipse.emf.ecore.EReference
import com.blasedef.onpa.typing.ExpressionsType
import com.blasedef.onpa.oNPA.ActionNot
import com.blasedef.onpa.oNPA.ActionExpression
import com.blasedef.onpa.oNPA.ActionOr
import com.blasedef.onpa.oNPA.ActionAnd
import com.blasedef.onpa.oNPA.ActionEquality
import com.blasedef.onpa.oNPA.ActionComparison

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class ONPAValidator extends AbstractONPAValidator {
	
	//STORE
	
	public static val SELF_REFERENCING_STORE = 'com.blaedef.onpa.dice.selfReferencingStore'
	
	@Check
	def checkNotSelfReferencing(Store store){
			
		var ArrayList<String> strings = new ArrayList<String>();
		
		strings.add(store.name)
		
		findReferencedRates(store.value,strings)
		
		var Set<String> setOfString = new HashSet<String>(strings);
		
		if(setOfString.size == strings.size)
			return //because there can't be any duplicates
		else
			error("Cannot have self referencing stores. '" + store.name + "' is seen in the expression",
				ONPAPackage::eINSTANCE.store_Value,
				com.blasedef.onpa.validation.ONPAValidator.SELF_REFERENCING_STORE
			)
		
	}
	
	def void findReferencedRates(Expression e, ArrayList<String> strings) {
		switch (e) {
			Or: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			And: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Equality:   		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Comparison: 		{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Sub: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Plu: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Mul:				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Div: 				{e.left.findReferencedRates(strings) e.right.findReferencedRates(strings)}
			Not: 				e.expression.findReferencedRates(strings)
			ReferencedStore: 	{strings.add(e.value.name)}
			FreeVariable:		{strings.add(e.value.substring(1))}
			}
	}
	
	public static val STORE_NAMES_UNIQUE = 'com.blaedef.onpa.dice.storeNamesUnique'
	
	@Check
	def checkStoresNamesUnique(Store store){
		
		var stores = getContainerOfType(store, typeof(Model)).stores
		
		var count = 0
		
		for(st : stores)
			if(st.name.contains(store.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique store names. '" + store.name + "' is repeated",
				ONPAPackage::eINSTANCE.store_Name,
				STORE_NAMES_UNIQUE
			)
			
	}
	
	//PROCESS
	
	public static val PROCESS_NAMES_UNIQUE = 'com.blaedef.onpa.dice.processNamesUnique'
	
	@Check
	def checkensureProcessCycles(Process process){
		
		var processes = getContainerOfType(process, typeof(Model)).processes
		
		var count = 0
		
		for(proc : processes)
			if(proc.name.contains(process.name))
				count = count + 1
				
		if(count == 1)
			return
		else 
			error("Must have unique process names. '" + process.name + "' is repeated",
				ONPAPackage::eINSTANCE.process_Name,
				PROCESS_NAMES_UNIQUE
			)
			
	}
	
	@Inject extension TypeProvider
	
	public static val WRONG_TYPE = "com.blasedef.onpa.dice.WrongType";
	
	@Check
	def checkType(Not not) {
		checkExpectedBoolean(not.expression,
				ONPAPackage$Literals::NOT__EXPRESSION)
	}
	
	@Check
	def checkType(ActionNot not) {
		checkExpectedBoolean(not.expression,
				ONPAPackage$Literals::ACTION_NOT__EXPRESSION)
	}
	
	@Check
	def checkType(Or or){
		checkExpectedBoolean(or.left,
			ONPAPackage$Literals::OR__LEFT
		)
		checkExpectedBoolean(or.right,
			ONPAPackage$Literals::OR__RIGHT
		)
	}
	
	@Check
	def checkType(ActionOr or){
		checkExpectedBoolean(or.left,
			ONPAPackage$Literals::ACTION_OR__LEFT
		)
		checkExpectedBoolean(or.right,
			ONPAPackage$Literals::ACTION_OR__RIGHT
		)
	}
	
	@Check
	def checkType(And and){
		checkExpectedBoolean(and.left,
			ONPAPackage$Literals::AND__LEFT
		)
		checkExpectedBoolean(and.right,
			ONPAPackage$Literals::AND__RIGHT
		)
	}
	
	@Check
	def checkType(ActionAnd and){
		checkExpectedBoolean(and.left,
			ONPAPackage$Literals::ACTION_AND__LEFT
		)
		checkExpectedBoolean(and.right,
			ONPAPackage$Literals::ACTION_AND__RIGHT
		)
	}
	
	@Check
	def checkType(Equality eq){
		checkExpectedBoolean(eq.left,
			ONPAPackage$Literals::EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			ONPAPackage$Literals::EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(ActionEquality eq){
		checkExpectedBoolean(eq.left,
			ONPAPackage$Literals::ACTION_EQUALITY__LEFT
		)
		checkExpectedBoolean(eq.right,
			ONPAPackage$Literals::ACTION_EQUALITY__RIGHT
		)
	}
	
	@Check
	def checkType(Comparison com){
		checkExpectedDouble(com.left,
			ONPAPackage$Literals::COMPARISON__LEFT
		)
		checkExpectedBoolean(com.right,
			ONPAPackage$Literals::COMPARISON__RIGHT
		)
	}
	
	@Check
	def checkType(ActionComparison com){
		checkExpectedDouble(com.left,
			ONPAPackage$Literals::ACTION_COMPARISON__LEFT
		)
		checkExpectedDouble(com.right,
			ONPAPackage$Literals::ACTION_COMPARISON__RIGHT
		)
	}
	
	def private checkExpectedBoolean(Expression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedBoolean(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::boolConstantType, reference)
	}
	
	def private checkExpectedDouble(Expression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedDouble(ActionExpression exp, EReference reference) {
		checkExpectedType(exp, TypeProvider::doubleConstantType, reference)
	}
	
	def private checkExpectedType(ActionExpression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType || actualType != TypeProvider::freeVariableType)
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private checkExpectedType(Expression exp,
			ExpressionsType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("Expected " + expectedType + " type, but was " + actualType,
					reference, WRONG_TYPE)
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(ActionExpression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
	def private ExpressionsType getTypeAndCheckNotNull(Expression exp,
			EReference reference) {
		var type = exp?.typeFor
		if (type == null)
			error("null type", reference, WRONG_TYPE)
		return type;
	}
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
